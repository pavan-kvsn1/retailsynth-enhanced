# Tunable Parameters for Calibration

This document lists ALL parameters that should be configurable for calibration, based on the RetailSynth paper approach.

---

## üö® **Current Problem**

Most parameters are **hardcoded** in the generators and cannot be tuned! This severely limits calibration effectiveness.

**Example from `customer_generator.py` line 30-31**:
```python
ages = np.random.choice([25, 35, 45, 55, 65], size=n, p=[0.2, 0.25, 0.25, 0.2, 0.1])
household_sizes = np.random.choice([1, 2, 3, 4, 5], size=n, p=[0.28, 0.35, 0.16, 0.15, 0.06])
```

These should be in the config!

---

## üìã **Parameters That Should Be Tunable**

### 1. Customer Demographics

#### Age Distribution
```python
age_values: List[int] = [25, 35, 45, 55, 65]
age_probabilities: List[float] = [0.2, 0.25, 0.25, 0.2, 0.1]
```

#### Household Size Distribution
```python
household_sizes: List[int] = [1, 2, 3, 4, 5]
household_size_probs: List[float] = [0.28, 0.35, 0.16, 0.15, 0.06]
```

#### Income Distribution (by age group)
```python
# Young (<=35)
young_income_brackets: List[str] = ['<30K', '30-50K', '50-75K']
young_income_probs: List[float] = [0.35, 0.4, 0.25]

# Middle (36-55)
middle_income_brackets: List[str] = ['30-50K', '50-75K', '75-100K', '>100K']
middle_income_probs: List[float] = [0.25, 0.35, 0.25, 0.15]

# Senior (>55)
senior_income_brackets: List[str] = ['30-50K', '50-75K', '75-100K']
senior_income_probs: List[float] = [0.4, 0.4, 0.2]
```

#### Children Distribution
```python
children_values: List[int] = [0, 1, 2, 3]
children_probs: List[float] = [0.3, 0.35, 0.25, 0.1]
single_probability: float = 0.3  # Probability of being single
```

---

### 2. Shopping Behavior

#### Visit Probability
```python
base_visit_probability: float = 0.15
visit_prob_by_personality: Dict[str, float] = {
    'price_anchor': 0.12,
    'convenience': 0.18,
    'planned': 0.15,
    'impulse': 0.20
}
```

#### Basket Size
```python
basket_size_lambda: float = 5.5  # Poisson mean
basket_size_by_trip: Dict[str, float] = {
    'quick_trip': 3.0,
    'major_shop': 12.0,
    'fill_in': 6.0,
    'special_occasion': 8.0
}
```

#### Trip Purpose Distribution
```python
trip_purpose_weights: Dict[str, float] = {
    'quick_trip': 0.3,
    'major_shop': 0.4,
    'fill_in': 0.2,
    'special_occasion': 0.1
}
```

---

### 3. Price Sensitivity & Utility

#### Price Sensitivity
```python
price_sensitivity_by_income: Dict[str, float] = {
    '<30K': 0.8,
    '30-50K': 0.6,
    '50-75K': 0.4,
    '75-100K': 0.3,
    '>100K': 0.2
}

price_sensitivity_by_personality: Dict[str, float] = {
    'price_anchor': 0.9,
    'convenience': 0.2,
    'planned': 0.5,
    'impulse': 0.4
}
```

#### Brand Loyalty
```python
brand_loyalty_mean: float = 0.6
brand_loyalty_std: float = 0.2
brand_loyalty_by_personality: Dict[str, float] = {
    'price_anchor': 0.3,
    'convenience': 0.7,
    'planned': 0.6,
    'impulse': 0.4
}
```

#### Promotion Response
```python
promotion_sensitivity_mean: float = 0.5
promotion_sensitivity_std: float = 0.2
promotion_quantity_boost: float = 1.5  # Multiplier for promoted items
```

---

### 4. Purchase History Weights

```python
loyalty_weight: float = 0.3
habit_weight: float = 0.4
inventory_weight: float = 0.5
variety_weight: float = 0.2
price_memory_weight: float = 0.1  # Reference price effect
```

---

### 5. Quantity Distribution

```python
quantity_mean: float = 1.5
quantity_std: float = 0.8
quantity_by_category: Dict[str, float] = {
    'BEVERAGES': 2.0,
    'DAIRY': 1.5,
    'SNACKS': 1.8,
    'MEAT': 1.2,
    'PRODUCE': 2.5
}
```

---

### 6. Store Loyalty

```python
store_loyalty_weight: float = 0.6
store_switching_probability: float = 0.15
distance_weight: float = 0.4
satisfaction_weight: float = 0.6
```

---

### 7. Temporal Dynamics

#### Customer Drift
```python
drift_rate: float = 0.05  # Weekly drift magnitude
drift_probability: float = 0.1  # Probability of drift per week
```

#### Inventory Depletion
```python
inventory_depletion_rate: float = 0.1  # Daily depletion rate
replenishment_threshold: float = 0.3  # When to repurchase
```

---

### 8. Category Preferences

```python
category_preference_mean: float = 0.5
category_preference_std: float = 0.2
category_weights_by_personality: Dict[str, Dict[str, float]] = {
    'price_anchor': {
        'GROCERY': 0.8,
        'BEVERAGES': 0.7,
        'SNACKS': 0.6
    },
    'convenience': {
        'PREPARED_FOODS': 0.9,
        'BEVERAGES': 0.8
    },
    # etc.
}
```

---

### 9. Assortment Role Preferences

```python
role_preference_by_personality: Dict[str, Dict[str, float]] = {
    'price_anchor': {
        'lpg_line': 0.9,
        'front_basket': 0.6,
        'mid_basket': 0.4,
        'back_basket': 0.2
    },
    'convenience': {
        'lpg_line': 0.3,
        'front_basket': 0.7,
        'mid_basket': 0.6,
        'back_basket': 0.5
    },
    # etc.
}
```

---

### 10. Basket Composition

```python
complement_probability: float = 0.4  # Probability of adding complements
substitute_avoidance: float = 0.8  # Avoid buying substitutes together
category_diversity_weight: float = 0.3  # Prefer diverse categories
```

---

## üéØ **What Needs to Be Done**

### Phase 1: Refactor Config (HIGH PRIORITY)
1. Create `EnhancedRetailConfigV2` with ALL tunable parameters
2. Update all generators to read from config instead of hardcoding
3. Maintain backward compatibility with current config

### Phase 2: Expand Optuna Tuning
1. Add all parameters to Optuna search space
2. Group parameters by objective (basket_size, revenue, etc.)
3. Add parameter constraints (e.g., probabilities must sum to 1)

### Phase 3: Advanced Calibration
1. Multi-objective optimization (Pareto front)
2. Parameter sensitivity analysis
3. Hierarchical tuning (demographics ‚Üí behavior ‚Üí basket)

---

## üìä **Estimated Impact**

**Current Tuning**: 8 parameters ‚Üí Limited calibration effectiveness

**Full Tuning**: 50+ parameters ‚Üí Much better fit to real data

**RetailSynth Paper**: They tune ~40 parameters using Optuna

---

## üöÄ **Recommended Approach**

### Option A: Quick Fix (1-2 hours)
Add top 20 most impactful parameters to config:
- Visit probability
- Basket size lambda
- Price sensitivity by income
- Brand loyalty
- Trip purpose weights
- Quantity distribution
- Purchase history weights

### Option B: Complete Refactor (1-2 days)
Move ALL parameters to config following RetailSynth structure:
- Create comprehensive config dataclass
- Update all generators
- Expand Optuna script
- Add parameter validation

### Option C: Hybrid (Recommended, 4-6 hours)
1. Add top 30 parameters to config (most impactful)
2. Leave less critical parameters hardcoded
3. Document which parameters are tunable
4. Expand Optuna to tune these 30 parameters

---

## üí° **Priority Parameters for Tuning**

Based on impact on key metrics:

### For Basket Size:
1. ‚úÖ `basket_size_lambda`
2. ‚úÖ `trip_purpose_weights`
3. ‚úÖ `basket_size_by_trip`

### For Revenue:
1. ‚úÖ `income_distribution`
2. ‚úÖ `price_sensitivity_by_income`
3. ‚úÖ `quantity_mean` / `quantity_std`
4. ‚úÖ `promotion_quantity_boost`

### For Visit Frequency:
1. ‚úÖ `base_visit_probability`
2. ‚úÖ `visit_prob_by_personality`
3. ‚úÖ `store_loyalty_weight`
4. ‚úÖ `inventory_depletion_rate`

### For Time Between Visits:
1. ‚úÖ `base_visit_probability`
2. ‚úÖ `inventory_depletion_rate`
3. ‚úÖ `replenishment_threshold`

---

## üìù **Next Steps**

1. **Decide on approach** (A, B, or C above)
2. **Create new config** with tunable parameters
3. **Update generators** to use config
4. **Expand Optuna script** with new parameters
5. **Run calibration** and measure improvement

---

**Bottom Line**: The current tuning is severely limited. We need to expose 30-50 parameters for effective calibration, following the RetailSynth paper's approach.
